From c4b15951aff5bdea7905bfeb801e470bc77d83c5 Mon Sep 17 00:00:00 2001
From: Sun Huashan <huashan.sun@intel.com>
Date: Fri, 22 Mar 2024 17:31:53 +0800
Subject: [PATCH] enable fuzzing optee os with afl-fuzzer

Signed-off-by: Sun Huashan <huashan.sun@intel.com>
---
 build_debug.sh                              |  15 +
 core/arch/x86_64/include/kernel/thread.h    |  12 +
 core/arch/x86_64/include/tee/arch_svc.h     |   1 +
 core/arch/x86_64/kernel/fault.c             |   5 +-
 core/arch/x86_64/kernel/kern.ld.S           |   3 +
 core/arch/x86_64/kernel/link_dummy.ld       |   2 +
 core/arch/x86_64/kernel/sub.mk              |  12 +
 core/arch/x86_64/kernel/thread.c            |   2 +
 core/arch/x86_64/mm/sub.mk                  |   3 +
 core/arch/x86_64/plat-standalonevm/conf.mk  |   2 +
 core/arch/x86_64/plat-standalonevm/sub.mk   |   3 +
 core/arch/x86_64/tee/arch_svc.c             |  83 ++
 core/arch/x86_64/tee/arch_svc_64.S          |  88 +-
 core/arch/x86_64/tee/arch_svc_private.h     |   2 +
 core/arch/x86_64/tee/sub.mk                 |   3 +
 core/arch/x86_64/x86_64.mk                  |  17 +-
 core/core.mk                                |   2 +-
 core/crypto/signed_hdr.c                    |   2 +
 core/crypto/sub.mk                          |   2 +
 core/drivers/sub.mk                         |   3 +
 core/include/kernel/afl.h                   |  94 +++
 core/include/kernel/ts_manager.h            |   5 +
 core/kernel/afl.c                           | 167 ++++
 core/kernel/afl_helper.S                    |  38 +
 core/kernel/afl_svc_trace.c                 | 892 ++++++++++++++++++++
 core/kernel/assert.c                        |   2 +
 core/kernel/panic.c                         |  13 +
 core/kernel/ree_fs_ta.c                     |  22 +
 core/kernel/sub.mk                          |  39 +
 core/kernel/tee_ta_manager.c                |  27 +
 core/kernel/ubsan.c                         |  42 +
 core/lib/libtomcrypt/sub.mk                 |   2 +
 core/mm/sub.mk                              |   3 +
 core/pta/afl.c                              | 114 +++
 core/pta/sub.mk                             |   4 +
 core/tee/entry_std.c                        |   2 +-
 core/tee/sub.mk                             |   2 +
 ldelf/sub.mk                                |   3 +
 lib/libdl/sub.mk                            |   3 +
 lib/libunw/sub.mk                           |   3 +
 lib/libutee/arch/x86_64/sub.mk              |   1 +
 lib/libutee/arch/x86_64/utee_syscalls_asm.S |  46 +
 lib/libutee/include/utee_syscalls.h         |   6 +
 lib/libutee/sub.mk                          |   2 +
 lib/libutils/ext/arch/x86_64/sub.mk         |   3 +
 lib/libutils/ext/sub.mk                     |   3 +
 lib/libutils/isoc/arch/x86_64/sub.mk        |   3 +
 lib/libutils/isoc/newlib/sub.mk             |   5 +
 lib/libutils/isoc/stack_check.c             |  15 +-
 lib/libutils/isoc/sub.mk                    |   6 +
 50 files changed, 1804 insertions(+), 25 deletions(-)
 create mode 100644 core/include/kernel/afl.h
 create mode 100644 core/kernel/afl.c
 create mode 100644 core/kernel/afl_helper.S
 create mode 100644 core/kernel/afl_svc_trace.c
 create mode 100644 core/pta/afl.c

diff --git a/build_debug.sh b/build_debug.sh
index 3b9041bb9..f764d5663 100755
--- a/build_debug.sh
+++ b/build_debug.sh
@@ -14,6 +14,21 @@ export DEBUG=1
 export CFG_TEE_BENCHMARK=n
 export PLATFORM=standalonevm
 
+export CFG_PM_DEBUG=0 \
+			 CFG_SECURE_DATA_PATH=n \
+			#  CFG_TEE_CORE_DEBUG=y \
+			#  CFG_DEBUG_INFO=y \
+			#  CFG_UNWIND=y \
+			#  CFG_CORE_SANITIZE_UNDEFINED=y \
+			#  CFG_CORE_SANITIZE_KADDRESS=n \
+			#  CFLAGS32="-fdiagnostics-color=always -O3" \
+			#  CFLAGS64="-fdiagnostics-color=always -O3" \
+			#  CFG_CC_OPTIMIZE_FOR_SIZE=n \
+			 CFG_CORE_HEAP_SIZE=2097152 \
+			#  CFG_CORE_UNMAP_CORE_AT_EL0=n \
+			#  CFG_SECSTOR_TA=n \
+			#  CFG_SECURE_TIME_SOURCE_REE=y
+			 
 make -j4
 
 if [ $? -ne 0 ]; then
diff --git a/core/arch/x86_64/include/kernel/thread.h b/core/arch/x86_64/include/kernel/thread.h
index d8da4f4a5..0b68df6a4 100644
--- a/core/arch/x86_64/include/kernel/thread.h
+++ b/core/arch/x86_64/include/kernel/thread.h
@@ -77,6 +77,18 @@ struct thread_ctx_regs {
 	uint64_t rcx;
 };
 
+struct thread_svc_regs {
+	uint64_t x0; /* rdi */
+	uint64_t x1; /* rsi */
+	uint64_t x2; /* rdx */
+	uint64_t x3; /* rcx */
+	uint64_t x4; /* r8  */
+	uint64_t x5; /* r9  */
+	uint64_t x6; /* r12 */
+	uint64_t x7; /* r13 */
+	uint64_t x8; /* scn */
+};
+
 struct thread_specific_data {
 	TAILQ_HEAD(, ts_session) sess_stack;
 	struct ts_ctx *ctx;
diff --git a/core/arch/x86_64/include/tee/arch_svc.h b/core/arch/x86_64/include/tee/arch_svc.h
index 8714e6024..bef360962 100644
--- a/core/arch/x86_64/include/tee/arch_svc.h
+++ b/core/arch/x86_64/include/tee/arch_svc.h
@@ -14,5 +14,6 @@ void ldelf_syscall(void);
 void __syscall_sys_return(unsigned long ret, unsigned long sp);
 void __syscall_panic(unsigned long code, unsigned long sp);
 uint64_t tee_svc_sys_return_helper(uint64_t ret, uint64_t sp);
+void tee_svc_handler(struct thread_svc_regs *regs);
 
 #endif /*TEE_ARCH_SVC_H*/
diff --git a/core/arch/x86_64/kernel/fault.c b/core/arch/x86_64/kernel/fault.c
index 0beffc320..aeee61b87 100644
--- a/core/arch/x86_64/kernel/fault.c
+++ b/core/arch/x86_64/kernel/fault.c
@@ -89,10 +89,13 @@ static void x86_pfe_handler(x86_iframe_t *frame)
 	}
 }
 
+extern __afl_reset_thread_ctx();
 void x86_exception_handler(x86_iframe_t *frame)
 {
 	unsigned int vector = frame->vector;
-
+#ifdef CFG_AFL_ENABLE
+	__afl_reset_thread_ctx();
+#endif
 	if (vector >= 0x20 && vector <= 0xFF) {
 #ifdef CFG_FOREIGN_INTR
 		//Only disable trace for foreign interrupt handling
diff --git a/core/arch/x86_64/kernel/kern.ld.S b/core/arch/x86_64/kernel/kern.ld.S
index 183a2e018..7a209b577 100644
--- a/core/arch/x86_64/kernel/kern.ld.S
+++ b/core/arch/x86_64/kernel/kern.ld.S
@@ -474,3 +474,6 @@ __asan_map_end = ((__asan_shadow_end - 1) / SMALL_PAGE_SIZE) *
 		 SMALL_PAGE_SIZE + SMALL_PAGE_SIZE;
 __asan_map_size = __asan_map_end - __asan_map_start;
 #endif /*CFG_CORE_SANITIZE_KADDRESS*/
+
+__afl_text_start = __text_start;
+__afl_text_end = __text_end;
diff --git a/core/arch/x86_64/kernel/link_dummy.ld b/core/arch/x86_64/kernel/link_dummy.ld
index 101975c55..a1d53fc36 100644
--- a/core/arch/x86_64/kernel/link_dummy.ld
+++ b/core/arch/x86_64/kernel/link_dummy.ld
@@ -94,3 +94,5 @@ __vcore_unpg_rx_start = .;
 PROVIDE(core_v_str = 0);
 PROVIDE(tee_entry_std = 0);
 PROVIDE(init_teecore = 0);
+__afl_text_start = .;
+__afl_text_end = .;
diff --git a/core/arch/x86_64/kernel/sub.mk b/core/arch/x86_64/kernel/sub.mk
index 41f135425..ddfa917e1 100644
--- a/core/arch/x86_64/kernel/sub.mk
+++ b/core/arch/x86_64/kernel/sub.mk
@@ -50,3 +50,15 @@ cflags-remove-unwind_arm32.c-y += -pg
 cflags-remove-unwind_arm64.c-$(CFG_ARM64_core) += -pg
 endif
 endif
+
+cflags-y += -fno-sanitize=all
+
+cflags-remove-fault.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-exceptions.S-y += -fsanitize-coverage=trace-pc
+cflags-remove-ldelf_loader.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-spin_lock_debug.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_time.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_time_ree.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-thread.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-thread_optee_smc.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-trace_ext.c-y += -fsanitize-coverage=trace-pc
diff --git a/core/arch/x86_64/kernel/thread.c b/core/arch/x86_64/kernel/thread.c
index 153a34b0f..d30171427 100644
--- a/core/arch/x86_64/kernel/thread.c
+++ b/core/arch/x86_64/kernel/thread.c
@@ -13,6 +13,7 @@
 #include <config.h>
 #include <io.h>
 #include <keep.h>
+#include <kernel/afl.h>
 #include <kernel/asan.h>
 #include <kernel/boot.h>
 #include <kernel/linker.h>
@@ -711,6 +712,7 @@ static void release_unused_kernel_stack(struct thread_ctx *thr __unused,
 
 int thread_state_suspend(uint32_t flags, vaddr_t sp, vaddr_t pc)
 {
+	// __afl_thread_suspend();
 	struct thread_core_local *l = thread_get_core_local();
 	int ct = l->curr_thread;
 
diff --git a/core/arch/x86_64/mm/sub.mk b/core/arch/x86_64/mm/sub.mk
index cf57687f3..375cdec8d 100644
--- a/core/arch/x86_64/mm/sub.mk
+++ b/core/arch/x86_64/mm/sub.mk
@@ -6,3 +6,6 @@ srcs-$(CFG_CORE_FFA) += mobj_ffa.c
 ifneq ($(CFG_CORE_FFA),y)
 srcs-$(CFG_CORE_DYN_SHM) += mobj_dyn_shm.c
 endif
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/arch/x86_64/plat-standalonevm/conf.mk b/core/arch/x86_64/plat-standalonevm/conf.mk
index c01151ddc..6458a3377 100644
--- a/core/arch/x86_64/plat-standalonevm/conf.mk
+++ b/core/arch/x86_64/plat-standalonevm/conf.mk
@@ -47,3 +47,5 @@ CFG_IN_TREE_EARLY_TAS += keymaster/dba51a17-0563-11e7-93b1-6fa7b0071a51
 
 $(call force,CFG_BOOT_SECONDARY_REQUEST,n)
 $(call force,CFG_DT,n)
+
+CFG_AFL_ENABLE ?= y
diff --git a/core/arch/x86_64/plat-standalonevm/sub.mk b/core/arch/x86_64/plat-standalonevm/sub.mk
index 8ddc2fd45..2dbd2c3b0 100644
--- a/core/arch/x86_64/plat-standalonevm/sub.mk
+++ b/core/arch/x86_64/plat-standalonevm/sub.mk
@@ -1,2 +1,5 @@
 global-incdirs-y += .
 srcs-y += main.c
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/core/arch/x86_64/tee/arch_svc.c b/core/arch/x86_64/tee/arch_svc.c
index 29914d91a..b6edc8bae 100644
--- a/core/arch/x86_64/tee/arch_svc.c
+++ b/core/arch/x86_64/tee/arch_svc.c
@@ -7,6 +7,7 @@
 
 #include <x86.h>
 #include <assert.h>
+#include <kernel/afl.h>
 #include <kernel/ldelf_syscalls.h>
 #include <kernel/misc.h>
 #include <kernel/panic.h>
@@ -116,6 +117,11 @@ const unsigned long tee_syscall_table[] = {
 	(unsigned long)syscall_not_supported,
 	(unsigned long)syscall_not_supported,
 	(unsigned long)syscall_cache_operation,
+
+#ifdef CFG_AFL_ENABLE
+	(unsigned long)syscall_afl_cov_bitmap_init,
+	(unsigned long)syscall_afl_cov_bitmap_shutdown,
+#endif
 };
 
 /*
@@ -146,3 +152,80 @@ uint64_t tee_svc_sys_return_helper(uint64_t ret, uint64_t sp)
 
     return ret;
 }
+
+static void set_svc_retval(struct thread_svc_regs *regs, uint64_t ret_val)
+{
+	regs->x0 = ret_val;
+}
+
+#ifdef CFG_AFL_ENABLE
+// Called by tee_svc_handler just before it starts executing a syscall handler
+static inline void __afl_cov_trace_start(struct ts_session *sess) {
+    assert(sess->afl_ctx != NULL);
+    assert(__afl_ctx_ptr() == NULL);
+
+    sess->afl_ctx->prev_loc = 0;
+
+    __afl_set_ctx_ptr(sess->afl_ctx);
+
+    sess->afl_ctx->enabled = true;
+}
+
+// Called by tee_svc_handler just after it finished executing a syscall handler
+static inline void __afl_cov_trace_stop(struct ts_session *sess) {
+    assert(sess->afl_ctx != NULL);
+
+    if (sess->afl_ctx != __afl_ctx_ptr()) {
+        EMSG("ctx: %p != %p\n", sess->afl_ctx, __afl_ctx_ptr());
+        // assert(sess->afl_ctx == __afl_ctx_ptr());
+    }
+
+    sess->afl_ctx->enabled = false;
+
+    __afl_set_ctx_ptr(0);
+}
+#endif
+
+void tee_svc_handler(struct thread_svc_regs *regs)
+{	
+	size_t scn;
+	uint32_t exceptions;
+
+	scn = regs->x8;
+// Disable interrupts
+	exceptions = thread_mask_exceptions(THREAD_EXCP_ALL);
+
+#ifdef CFG_AFL_ENABLE
+	struct ts_session *sess;
+
+    assert((sess = ts_get_current_session()) != NULL);
+
+	if (scn <= TEE_SCN_MAX && sess->afl_ctx != NULL) { // Only trace when we have a bitmap and it's not an AFL syscall
+		if (scn != TEE_SCN_LOG) // We use log extensively in our TA
+			__afl_cov_trace_start(sess);
+
+		set_svc_retval(regs, tee_svc_do_call(regs));
+
+		if (scn != TEE_SCN_LOG)
+			__afl_cov_trace_stop(sess);
+	}
+	else {
+		uint64_t args[TEE_SVC_MAX_ARGS];
+
+		if (scn <= TEE_SCN_MAX) { // Normals SVCs
+			__afl_svc_trace_log_call(scn, regs, &args);
+		}
+
+		set_svc_retval(regs, tee_svc_do_call(regs));
+
+		if (scn <= TEE_SCN_MAX) {
+			__afl_svc_trace_log_call_post(scn, regs, &args);
+		}
+	}
+#else
+	set_svc_retval(regs, tee_svc_do_call(regs));
+#endif
+
+	/* Restore interrupts */
+	thread_unmask_exceptions(exceptions);
+}
diff --git a/core/arch/x86_64/tee/arch_svc_64.S b/core/arch/x86_64/tee/arch_svc_64.S
index fd6f771a0..02bdd8db0 100644
--- a/core/arch/x86_64/tee/arch_svc_64.S
+++ b/core/arch/x86_64/tee/arch_svc_64.S
@@ -60,14 +60,74 @@ FUNC tee_syscall , :
     pushq %r14
     pushq %r11
     pushq %r10
+    pushq %rbx
+    pushq %rbp
+
+/* prepare arguments for tee_scv_handler */
+    pushq %rax
+    pushq %r13
+    pushq %r12
     pushq %r9
     pushq %r8
     pushq %rcx
     pushq %rdx
-    pushq %rbx
-    pushq %rbp
     pushq %rsi
     pushq %rdi
+
+    movq %rsp, %rdi
+    call tee_svc_handler
+
+    popq %rdi
+    popq %rsi
+    popq %rdx
+    popq %rcx
+    popq %r8
+    popq %r9
+    popq %r12
+    popq %r13
+    popq %rbp /* will be covered */
+
+    movq %rdi, %rax /* result set by tee_scv_handler */
+
+    popq %rbp
+    popq %rbx
+    popq %r10
+    popq %r11
+    popq %r14
+    popq %r15
+
+    popq %rcx /* pop rsp */
+    popq %rdx /* pop rip */
+    rex64 sysexit
+
+END_FUNC tee_syscall
+
+/*
+ * called from tee_scv_handler
+ */
+FUNC tee_svc_do_call , :
+    pushq %rbp
+    movq %rsp, %rbp  
+
+    pushq %rbx
+    pushq %r12
+    pushq %r13
+    pushq %r14
+    pushq %r15
+
+/* prepare arguments for syscall */
+    movq %rdi, %r15
+
+    movq (%r15), %rdi
+    movq 8(%r15), %rsi
+    movq 16(%r15), %rdx
+    movq 24(%r15), %rcx
+    movq 32(%r15), %r8
+    movq 40(%r15), %r9
+    movq 48(%r15), %r12
+    movq 56(%r15), %r13
+    movq 64(%r15), %rax
+
     pushq %r13
     pushq %r12
 
@@ -85,26 +145,16 @@ FUNC tee_syscall , :
     movq %r13,%rdx
     call *(%rax)
 
-    popq %r12
+    popq %r15
+    popq %r14
     popq %r13
-    popq %rdi
-    popq %rsi
-    popq %rbp
+    popq %r12
     popq %rbx
-    popq %rdx
-    popq %rcx
-    popq %r8
-    popq %r9
-    popq %r10
-    popq %r11
-    popq %r14
-    popq %r15
-
-    popq %rcx /* pop rsp */
-    popq %rdx /* pop rip */
-    rex64 sysexit
 
-END_FUNC tee_syscall
+    movq %rbp, %rsp
+    popq %rbp 
+    ret
+END_FUNC tee_svc_do_call
 
 FUNC ldelf_syscall , :
     sti
diff --git a/core/arch/x86_64/tee/arch_svc_private.h b/core/arch/x86_64/tee/arch_svc_private.h
index bfdb12484..0bc0be706 100644
--- a/core/arch/x86_64/tee/arch_svc_private.h
+++ b/core/arch/x86_64/tee/arch_svc_private.h
@@ -13,4 +13,6 @@
  */
 typedef void (*syscall_t)(void);
 
+uint64_t tee_svc_do_call(struct thread_svc_regs *regs);
+
 #endif /*ARCH_SVC_PRIVATE_H*/
diff --git a/core/arch/x86_64/tee/sub.mk b/core/arch/x86_64/tee/sub.mk
index d5fbc27d9..909b16bdc 100644
--- a/core/arch/x86_64/tee/sub.mk
+++ b/core/arch/x86_64/tee/sub.mk
@@ -6,3 +6,6 @@ endif
 srcs-y += entry_fast.c
 cppflags-entry_fast.c-y += -DTEE_IMPL_GIT_SHA1=$(TEE_IMPL_GIT_SHA1)
 srcs-y += cache.c
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/arch/x86_64/x86_64.mk b/core/arch/x86_64/x86_64.mk
index 84924b854..58f05f2a0 100644
--- a/core/arch/x86_64/x86_64.mk
+++ b/core/arch/x86_64/x86_64.mk
@@ -11,7 +11,7 @@ include mk/cc-option.mk
 CFG_LTC_OPTEE_THREAD ?= y
 CFG_LPAE_ADDR_SPACE_SIZE ?= (1ull << 32)
 
-CFG_MMAP_REGIONS ?= 13
+CFG_MMAP_REGIONS ?= 24
 CFG_RESERVED_VASPACE_SIZE ?= (1024 * 1024 * 10)
 
 CFG_KERN_LINKER_FORMAT ?= "elf64-x86-64"
@@ -46,6 +46,21 @@ platform-aflags-generic ?= -pipe
 platform-aflags-generic += -D__ASSEMBLY__
 x86-64-platform-cppflags += -DX86_64=1 -D__LP64__=1
 
+ifeq ($(CFG_AFL_ENABLE),y)
+core-platform-cflags += -fsanitize-coverage=trace-pc
+# core-platform-cflags += -O3
+# core-platform-cflags += -ffunction-sections
+# core-platform-cflags += -fdata-sections
+# core-platform-cflags += -pipe
+# core-platform-cflags += -g3
+# core-platform-cflags += -strict-align
+# core-platform-cflags += -mgeneral-regs-only
+# core-platform-cflags += -fsanitize=bounds-strict,pointer-overflow,signed-integer-overflow,vla-bound,object-size,builtin,enum,nonnull-attribute,returns-nonnull-attribute 
+# core-platform-cflags += -fstack-protector-strong
+# core-platform-cflags += -DCFG_AFL_ENABLE
+# core-platform-cflags += -DCFG_AFL_SKIP_TA_AUTHENTICATION
+endif
+
 ifeq ($(DEBUG),1)
 # For backwards compatibility
 $(call force,CFG_CC_OPT_LEVEL,0)
diff --git a/core/core.mk b/core/core.mk
index c4c070ee2..51811700f 100644
--- a/core/core.mk
+++ b/core/core.mk
@@ -25,7 +25,7 @@ cppflags$(sm)	+= -I$(out-dir)/core/include
 cppflags$(sm)	+= $(core-platform-cppflags)
 cflags$(sm)	+= $(core-platform-cflags)
 ifeq ($(CFG_CORE_SANITIZE_UNDEFINED),y)
-cflags$(sm)	+= -fsanitize=undefined
+# cflags$(sm)	+= -fsanitize=undefined
 endif
 ifeq ($(CFG_CORE_SANITIZE_KADDRESS),y)
 ifeq ($(CFG_ASAN_SHADOW_OFFSET),)
diff --git a/core/crypto/signed_hdr.c b/core/crypto/signed_hdr.c
index bfec1c3d7..2efe56b09 100644
--- a/core/crypto/signed_hdr.c
+++ b/core/crypto/signed_hdr.c
@@ -54,6 +54,7 @@ TEE_Result shdr_verify_signature(const struct shdr *shdr)
 	if (shdr->magic != SHDR_MAGIC)
 		return TEE_ERROR_SECURITY;
 
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	if (TEE_ALG_GET_MAIN_ALG(shdr->algo) != TEE_MAIN_ALGO_RSA)
 		return TEE_ERROR_SECURITY;
 
@@ -83,5 +84,6 @@ out:
 	crypto_acipher_free_rsa_public_key(&key);
 	if (res)
 		return TEE_ERROR_SECURITY;
+#endif
 	return TEE_SUCCESS;
 }
diff --git a/core/crypto/sub.mk b/core/crypto/sub.mk
index 873ef9868..8bb40ad2a 100644
--- a/core/crypto/sub.mk
+++ b/core/crypto/sub.mk
@@ -36,3 +36,5 @@ srcs-$(CFG_CRYPTO_ECB) += sm4-ecb.c
 srcs-$(CFG_CRYPTO_CBC) += sm4-cbc.c
 srcs-$(CFG_CRYPTO_CTR) += sm4-ctr.c
 endif
+
+cflags-remove-signed_hdr.c-y += -fsanitize-coverage=trace-pc
diff --git a/core/drivers/sub.mk b/core/drivers/sub.mk
index 24fe69f58..39cc43d69 100644
--- a/core/drivers/sub.mk
+++ b/core/drivers/sub.mk
@@ -47,3 +47,6 @@ subdirs-$(CFG_VIRTIO_TEE) += virtio
 srcs-$(CFG_IVSHMEM) += ivshmem.c
 srcs-$(CFG_X86_RNG) += x86_rng.c
 subdirs-$(CFG_EDK2_TPM) += tpm
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/core/include/kernel/afl.h b/core/include/kernel/afl.h
new file mode 100644
index 000000000..69f1c12b0
--- /dev/null
+++ b/core/include/kernel/afl.h
@@ -0,0 +1,94 @@
+#ifndef __KERNEL_AFL_H
+#define __KERNEL_AFL_H
+
+#include <assert.h>
+#include <kernel/tee_ta_manager.h>
+
+#define AFL_FULL_MAP
+//#define AFL_DEBUG
+
+#define MAP_SIZE (1 << 12)
+#define FULL_MAP_SIZE (1 << 16)
+
+typedef struct afl_ctx {
+    bool enabled;
+    char bitmap[MAP_SIZE];
+    uint64_t prev_loc;
+
+    void* input;
+    size_t input_len;
+};
+
+typedef struct afl_svc_trace_ctx {
+    bool trace_enabled;
+
+    // cmd buffer
+    void* cmd_buf; /* malloc */
+    void* cmd_buf_last_p;
+    void* cmd_buf_last_append_p;
+
+    // data buffer
+    void* data_buf;  /* malloc */
+    void* data_buf_append_p;
+
+    // buffer ids
+    uint32_t num_bufs;
+    void** buf_ptrs;  /* malloc */
+    uint32_t* buf_sizes;  /* malloc */
+
+    // handles
+    uint32_t num_handles;
+    uint32_t* handles;  /* malloc */
+    uint32_t* handle_buf_ids;  /* malloc */
+};
+
+/* called from thread.c */
+void __afl_thread_suspend(void);
+void __afl_thread_resume(void);
+
+struct thread_svc_regs;
+
+void __afl_svc_trace_log_call(uint64_t scn, struct thread_svc_regs *regs, uint64_t* args);
+void __afl_svc_trace_log_call_post(uint64_t scn, const struct thread_svc_regs *regs, const uint64_t* args);
+
+/* called by afl-tee TA */
+TEE_Result syscall_afl_cov_bitmap_init(void* input, size_t input_len);
+TEE_Result syscall_afl_cov_bitmap_shutdown(void* dst);
+
+/* called by afl-tee PTA */
+TEE_Result afl_svc_trace_start(uint32_t session_id);
+TEE_Result afl_svc_trace_stop(uint32_t session_id, void* dst, uint32_t* dst_len);
+
+#ifdef AFL_FULL_MAP
+TEE_Result afl_copy_full_map(void* buf, size_t* buf_len);
+TEE_Result afl_reset_full_map();
+#endif
+
+#ifdef X86_64
+struct afl_ctx *global_afl_ctx;
+
+static inline struct afl_ctx* __afl_ctx_ptr(void) 
+{
+    return global_afl_ctx;
+}
+
+static inline void __afl_set_ctx_ptr(struct afl_ctx* ptr) 
+{
+    global_afl_ctx = ptr;
+}
+#else
+static inline struct afl_ctx* __afl_ctx_ptr(void) {
+    register uintptr_t ptr;
+
+    /* Note: tpidrro_el0 is readable by EL0, however this will only leak a kernel VA */
+    __asm volatile ("mrs %0, tpidrro_el0" : "=r" (ptr) );
+
+    return (struct afl_ctx*)ptr;
+}
+
+static inline void __afl_set_ctx_ptr(struct afl_ctx* ptr) {
+    asm volatile("msr tpidrro_el0, %0" :: "r" (ptr) : "memory");
+}
+#endif /* X86_64 */
+
+#endif
\ No newline at end of file
diff --git a/core/include/kernel/ts_manager.h b/core/include/kernel/ts_manager.h
index 65cb93f96..1cbea03fb 100644
--- a/core/include/kernel/ts_manager.h
+++ b/core/include/kernel/ts_manager.h
@@ -36,6 +36,11 @@ struct ts_session {
 #else
 	bool (*handle_svc)(struct thread_svc_regs *regs);
 #endif
+
+#if defined(CFG_AFL_ENABLE)
+	struct afl_ctx* afl_ctx; 
+	struct afl_svc_trace_ctx* svc_trace_ctx; 
+#endif
 };
 
 enum ts_gprof_status {
diff --git a/core/kernel/afl.c b/core/kernel/afl.c
new file mode 100644
index 000000000..71c4d11e3
--- /dev/null
+++ b/core/kernel/afl.c
@@ -0,0 +1,167 @@
+#include <assert.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <trace.h>
+#include <initcall.h>
+
+#include <platform_config.h>
+
+#include <kernel/afl.h>
+#include <kernel/panic.h>
+#include <kernel/linker.h>
+
+#ifdef CFG_CORE_UNMAP_CORE_AT_EL0
+#error AFL support is incompatible with CFG_CORE_UNMAP_CORE_AT_EL0
+#endif
+
+extern uint8_t __afl_text_start[];
+extern uint8_t __afl_text_end[];
+
+static uintptr_t _text_start = &__afl_text_start;
+static uintptr_t _text_end = &__afl_text_end;
+
+#define afl_cov_is_enabled(task_id) ((__afl_cov_enabled & ((uint64_t)1 << task_id)) != 0)
+#define afl_cov_enable(task_id) do { __afl_cov_enabled |= (uint64_t)1 << task_id; } while(0);
+#define afl_cov_disable(task_id) do { __afl_cov_enabled &= ~((uint64_t)1 << task_id); } while(0);
+
+#ifdef AFL_FULL_MAP
+static uint8_t __afl_cov_full_map[FULL_MAP_SIZE];
+#endif
+
+#define unlikely(x)     __builtin_expect((x),0)
+
+void __sanitizer_cov_trace_pc(void);
+void sanitizer_cov_trace_pc(uintptr_t addr);
+
+void __afl_reset_thread_ctx(void) {
+    // Set thread info registers to default values
+    __afl_set_ctx_ptr(0);
+}
+
+void __afl_thread_suspend(void) {
+    __afl_reset_thread_ctx();
+}
+
+void __afl_thread_resume(void) {
+    struct ts_session *sess;
+
+    //EMSG("Resume: tee_ta_get_current_session(&sess) == TEE_SUCCESS: %x", tee_ta_get_current_session(&sess) == TEE_SUCCESS);    
+
+    if ((sess = ts_get_current_session()) != NULL && sess->afl_ctx && sess->afl_ctx->enabled) {
+        __afl_set_ctx_ptr(sess->afl_ctx);
+    }
+}
+
+void sanitizer_cov_trace_pc(uintptr_t addr) {
+
+    static idx = 0;
+
+    struct afl_ctx* ctx = __afl_ctx_ptr();
+
+    if (ctx != NULL) {
+#ifdef AFL_FULL_MAP
+        uintptr_t map_addr = (addr - _text_start) >> 1;
+        size_t map_idx = map_addr / 8;
+        size_t map_bit = map_addr % 8;
+
+        assert(map_idx < sizeof(__afl_cov_full_map));
+
+        __afl_cov_full_map[map_idx] |= 1u << map_bit;
+#endif
+
+#ifdef AFL_DEBUG
+        struct ts_session *sess;
+
+        assert((sess = ts_get_current_session()) != NULL);
+
+        if (sess->afl_ctx != ctx) {
+            EMSG("ctx: %p != %p", sess->afl_ctx, ctx);
+            assert(sess->afl_ctx == ctx);
+        }
+#endif
+
+        // Right shift 1 as instructions are 2-byte (thumb) or 4-byte aligned(arm or aarch64)
+        addr = (addr >> 1);
+
+        //if ((ctx->prev_loc & (~(MAP_SIZE - 1))) != 0) {
+        //    EMSG("Incorrect prev_loc: %x mask: %x val: %x", ctx->prev_loc, (~(MAP_SIZE - 1)), ctx->prev_loc & (~(MAP_SIZE - 1)));
+        //    assert((ctx->prev_loc & (~(MAP_SIZE - 1))) == 0);
+        //}
+
+        ctx->bitmap[(addr ^ ctx->prev_loc) & (MAP_SIZE - 1)]++;
+        //ctx->prev_loc = (addr >> 1) & (MAP_SIZE - 1);
+        ctx->prev_loc = (addr >> 1); 
+    }
+}
+
+TEE_Result syscall_afl_cov_bitmap_init(void* input, size_t input_len) {
+    struct ts_session *sess;
+
+    assert((sess = ts_get_current_session()) != NULL);
+
+    assert(sess->afl_ctx == NULL);
+    assert(__afl_ctx_ptr() == NULL);
+
+    sess->afl_ctx = malloc(sizeof(struct afl_ctx));
+
+    if (unlikely(sess->afl_ctx == NULL)) {
+        EMSG("Out of memory");
+        panic();
+    }
+
+    memset(sess->afl_ctx, 0, sizeof(struct afl_ctx));
+
+    sess->afl_ctx->input = input;
+    sess->afl_ctx->input_len = input_len;
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result syscall_afl_cov_bitmap_shutdown(void* dst) {
+    struct ts_session *sess;
+
+    assert((sess = ts_get_current_session()) != NULL);
+
+    assert(sess->afl_ctx != NULL);
+    assert(__afl_ctx_ptr() == NULL);
+
+    if (dst) {
+        memcpy(dst, sess->afl_ctx->bitmap, MAP_SIZE);
+    }
+
+    free(sess->afl_ctx);
+    sess->afl_ctx = NULL;
+
+    return TEE_SUCCESS;
+}
+
+#ifdef AFL_FULL_MAP
+TEE_Result afl_copy_full_map(void* buf, size_t* buf_len) {
+    memcpy(buf, __afl_cov_full_map, FULL_MAP_SIZE);
+
+    *buf_len = FULL_MAP_SIZE;
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result afl_reset_full_map() {
+    memset(__afl_cov_full_map, 0, FULL_MAP_SIZE);
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result afl_init(void)
+{
+    EMSG("AFL cov Start: %x End: %x Map: %x (need: %x)", _text_start, _text_end, sizeof(__afl_cov_full_map), (_text_end - _text_start) / 8ull / 2ull);
+
+    assert((_text_end - _text_start) / 8ull / 2ull < sizeof(__afl_cov_full_map));
+
+    __afl_reset_thread_ctx();
+
+    return TEE_SUCCESS;
+}
+
+driver_init(afl_init);
+#endif
\ No newline at end of file
diff --git a/core/kernel/afl_helper.S b/core/kernel/afl_helper.S
new file mode 100644
index 000000000..1d0931901
--- /dev/null
+++ b/core/kernel/afl_helper.S
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: BSD-2-Clause */
+/*
+ * Copyright (c) 2024, Intel Corporation
+ */
+#include <asm.S>
+
+/* void __sanitizer_cov_trace_pc(void) */
+FUNC __sanitizer_cov_trace_pc , :
+    /* hold the return address of each code block */
+
+    pushq %rbp
+    movq %rsp, %rbp
+    pushq %rbx
+    pushq %r12
+    pushq %r13
+    pushq %r14
+    pushq %r15
+
+    pushq %r10
+    pushq %r11
+
+#ifdef CFG_AFL_ENABLE
+    movq 8(%rbp), %rdi
+    call sanitizer_cov_trace_pc
+#endif
+
+    popq %r11
+    popq %r10
+
+    popq %r15
+    popq %r14
+    popq %r13
+    popq %r12
+    popq %rbx
+    movq %rbp, %rsp
+    popq %rbp
+    retq
+END_FUNC __sanitizer_cov_trace_pc
\ No newline at end of file
diff --git a/core/kernel/afl_svc_trace.c b/core/kernel/afl_svc_trace.c
new file mode 100644
index 000000000..ece8a9dd6
--- /dev/null
+++ b/core/kernel/afl_svc_trace.c
@@ -0,0 +1,892 @@
+#include <assert.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <trace.h>
+#include <util.h>
+
+#include <kernel/panic.h>
+#include <kernel/thread.h>
+#include <kernel/tee_ta_manager.h>
+#include <kernel/user_access.h>
+
+#include <mm/tee_mm.h>
+#include <mm/vm.h>
+
+#include <tee/tee_svc.h>
+
+#include <initcall.h>
+#include <platform_config.h>
+#include <tee_syscall_numbers.h>
+
+#include <kernel/afl.h>
+
+// evil hack
+#define abort panic
+
+#include "../../../afl-tee/shared/info.c"
+#include "../../../afl-tee/shared/validate.c"
+
+#include "../../../afl-tee/shared/include/afl-tee-trace.h"
+
+static void dump_afl_trace_ctx(struct afl_svc_trace_ctx* ctx) {
+    EMSG("Trace Enabled: %s\n", ctx->trace_enabled ? "true" : "false");
+
+    // Command buffer
+    EMSG("Command Buffer: %p\n", ctx->cmd_buf);
+    EMSG("Command Buffer Last Pointer: %p\n", ctx->cmd_buf_last_p);
+    EMSG("Command Buffer Last Append Pointer: %p\n", ctx->cmd_buf_last_append_p);
+
+    // Data buffer
+    EMSG("Data Buffer: %p\n", ctx->data_buf);
+    EMSG("Data Buffer Append Pointer: %p\n", ctx->data_buf_append_p);
+
+    // Buffer IDs
+    EMSG("Number of Buffers: %u\n", ctx->num_bufs);
+    if (ctx->num_bufs > 0) {
+        EMSG("Buffer Pointers:\n");
+        for (uint32_t i = 0; i < ctx->num_bufs; ++i) {
+            EMSG("  [%u]: %p\n", i, ctx->buf_ptrs[i]);
+        }
+        EMSG("Buffer Sizes:\n");
+        for (uint32_t i = 0; i < ctx->num_bufs; ++i) {
+            EMSG("  [%u]: %u\n", i, ctx->buf_sizes[i]);
+        }
+    }
+
+    // Handles
+    EMSG("Number of Handles: %u\n", ctx->num_handles);
+    if (ctx->num_handles > 0) {
+        EMSG("Handles:\n");
+        for (uint32_t i = 0; i < ctx->num_handles; ++i) {
+            EMSG("  [%u]: %u (Buffer ID: %u)\n", i, ctx->handles[i], ctx->handle_buf_ids[i]);
+        }
+    }
+}
+
+static bool has_buffer(struct afl_svc_trace_ctx* ctx, void* ptr, size_t size) {
+    if (ctx->buf_ptrs && ctx->buf_sizes) {
+        for (uint32_t i = 0; i < ctx->num_bufs; i++) {
+            if (ctx->buf_ptrs[i] == ptr && size <= ctx->buf_sizes[i]) {
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+static uint32_t lookup_buffer_id(struct afl_svc_trace_ctx* ctx, void* ptr, size_t size) {
+    if (ctx->buf_ptrs && ctx->buf_sizes) {
+        for (uint32_t i = 0; i < ctx->num_bufs; i++) {
+            if (ctx->buf_ptrs[i] == ptr && size <= ctx->buf_sizes[i]) {
+                return i;
+            }
+        }
+    }
+
+    assert(0);
+}
+
+static uint32_t assign_buffer_id(struct afl_svc_trace_ctx* ctx, void* ptr, size_t size) {
+    assert(ctx->num_bufs + 1 < MAX_BUF_COUNT);
+
+    ctx->buf_ptrs = (void**)realloc(ctx->buf_ptrs, (ctx->num_bufs + 1) * sizeof(void*));
+    ctx->buf_sizes = (uint32_t*)realloc(ctx->buf_sizes, (ctx->num_bufs + 1) * sizeof(&ctx->buf_sizes[0]));
+
+    assert(ctx->buf_ptrs != NULL);
+    assert(ctx->buf_sizes != NULL);
+
+    ctx->buf_ptrs[ctx->num_bufs] = ptr;
+    ctx->buf_sizes[ctx->num_bufs] = size;
+
+    return ctx->num_bufs++;
+}
+
+static inline size_t get_buf_size(uint32_t scn, uint64_t* args, uint64_t arg_info) {
+    uint8_t len_arg_nr = GET_ARG_BUF_LEN_ARG(arg_info);
+    uint8_t arg_buf_size = GET_ARG_BUF_SIZE(arg_info);
+    
+    if (len_arg_nr < syscall_num_args(scn)) {
+        uint32_t len_arg_info = syscall_arg_info(scn, len_arg_nr);
+
+        switch (len_arg_info & 0xFF) {
+            case ARG_VALUE:
+                if (arg_buf_size > 0) {
+                    return args[len_arg_nr] * arg_buf_size;
+                }
+                else {
+                    return args[len_arg_nr];
+                }
+
+            case ARG_VALUE_INOUT_PTR: {
+                uint32_t len = 0;
+
+                if (copy_from_user(&len, args[len_arg_nr], sizeof(len)) == TEE_SUCCESS) {
+                    if (arg_buf_size > 0) {
+                        return len * arg_buf_size;
+                    }
+                    else {
+                        return len;
+                    }
+                }
+                break;
+            }
+
+            default:
+                EMSG("Unexpected arg type: %x", len_arg_info);
+                assert(0);
+        }
+    }
+    else if (arg_buf_size > 0) {
+        return arg_buf_size;
+    }
+
+    return SIZE_MAX;
+}
+
+static inline bool has_handle(struct afl_svc_trace_ctx* ctx, uint32_t handle) {
+    for (uint32_t i = 0; i < ctx->num_handles; i++) {
+        if (ctx->handles[i] == handle) {
+            return true;
+        }
+    }
+
+    return false;
+}
+
+static inline uint32_t lookup_handle_buffer_id(struct afl_svc_trace_ctx* ctx, uint32_t handle) {
+    for (uint32_t i = 0; i < ctx->num_handles; i++) {
+        if (ctx->handles[i] == handle) {
+            return ctx->handle_buf_ids[i];
+        }
+    }
+
+    assert(0);
+}
+
+static inline void track_created_handles(struct afl_svc_trace_ctx* ctx, uint32_t scn, uint64_t* args) {
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_HANDLE_OUT_PTR:
+                {
+                    uint32_t handle;
+
+                    // we should have one assigned in append_cmd()
+                    // ?? if cmd buffer bigger than 1kb, it did not assign ??
+                    if (!has_buffer(ctx, (void*)args[i], sizeof(handle)))
+                        break;
+                    
+                    assert(copy_from_user(&handle, (void*)args[i], sizeof(handle)) == TEE_SUCCESS);
+
+                    if (has_handle(ctx, handle) && (lookup_handle_buffer_id(ctx, handle) == lookup_buffer_id(ctx, (void*)args[i], sizeof(handle)))) {
+                    }
+                    else { // register as a new handle
+                        ctx->handles = realloc(ctx->handles, (ctx->num_handles + 1) * sizeof(handle));
+                        ctx->handle_buf_ids = realloc(ctx->handle_buf_ids, (ctx->num_handles + 1) * sizeof(handle));
+
+                        assert(ctx->handles != NULL);
+                        assert(ctx->handle_buf_ids != NULL);
+
+                        ctx->handles[ctx->num_handles] = handle;
+                        ctx->handle_buf_ids[ctx->num_handles] = lookup_buffer_id(ctx, (void*)args[i], sizeof(handle));
+
+                        ctx->num_handles++;
+                    }
+                }
+                break;
+        }
+    }
+}
+
+static inline void print_invoke_syscall_info(uint32_t scn, uint64_t* args) {
+    static char buf[256] = {0};
+
+    size_t off = 0;
+
+    off += snprintf(&buf[off], sizeof(buf) - off, "%s[%i](", syscall_name(scn), scn);
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        if (i >= 1) {
+            off += snprintf(&buf[off], sizeof(buf) - off, ", ");
+        }
+
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_VALUE:
+            case ARG_HANDLE:
+
+            case ARG_VALUE_OUT_PTR:
+            case ARG_HANDLE_OUT_PTR:
+                off += snprintf(&buf[off], sizeof(buf) - off, "%x", args[i]);
+                break;
+
+            case ARG_VALUE_INOUT_PTR:
+                {
+                    uint32_t val;
+
+                    if (copy_from_user(&val, (void*)args[i], sizeof(val)) == TEE_SUCCESS) {
+                        off += snprintf(&buf[off], sizeof(buf) - off, "%x=%x", args[i], val);    
+                    }
+                    else {
+                        off += snprintf(&buf[off], sizeof(buf) - off, "%x=<invalid addr>", args[i]);    
+                    }
+                }
+                break;
+
+            case ARG_BUF_IN_ADDR:
+            case ARG_BUF_OUT_ADDR:
+            case ARG_BUF_INOUT_ADDR:
+                off += snprintf(&buf[off], sizeof(buf) - off, "*%x:%x", args[i], get_buf_size(scn, args, arg_info));
+                break;
+
+            default:
+                assert(0);
+        }
+    }
+
+    trace_ext_puts(buf);
+
+    // Dump attributes
+    off = 0;
+    off += snprintf(&buf[off], sizeof(buf) - off, ")\n");
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_BUF_IN_ADDR:
+            case ARG_BUF_INOUT_ADDR:
+                if (GET_ARG_BUF_TYPE(arg_info) > 0) {
+                    switch (GET_ARG_BUF_TYPE(arg_info)) {
+                        case ARG_TYPE_ATTR: 
+                            {
+                                uint32_t num_args = get_buf_size(scn, args, arg_info) / sizeof(struct utee_attribute);
+
+                                assert(get_buf_size(scn, args, arg_info) % sizeof(struct utee_attribute) == 0);
+
+                                struct utee_attribute attr;
+
+                                for (uint32_t attrn = 0; attrn < num_args; attrn++) {
+                                    assert(copy_from_user(&attr, &((struct utee_attribute*)args[i])[attrn], sizeof(attr)) == TEE_SUCCESS);
+
+                                    off += snprintf(&buf[off], sizeof(buf) - off, " attr %x { id: %x, a: %x, b: %x }\n", attrn, attr.attribute_id, attr.a, attr.b);
+                                }
+                            }
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+        }
+    }
+
+    trace_ext_puts(buf);
+}
+
+static inline void print_post_invoke_syscall_info(uint32_t scn, uint64_t* args, uint32_t ret_val) {
+    static char buf[256] = {0};
+    size_t off = 0;
+
+    bool had_first = false;
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        if (had_first) {
+            off += snprintf(&buf[off], sizeof(buf) - off, ", ");
+        }
+
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_HANDLE_OUT_PTR:
+                if (had_first) {
+                    off += snprintf(&buf[off], sizeof(buf) - off, ", ");
+                }
+                else {
+                    off += snprintf(&buf[off], sizeof(buf) - off, " [");
+                    had_first = true;
+                }
+
+                off += snprintf(&buf[off], sizeof(buf) - off, "*%p = %x", args[i], *((uint32_t*)args[i]));
+                break;
+        }
+    }
+
+    if (had_first) {
+        off += snprintf(&buf[off], sizeof(buf) - off, "]\n");
+    }
+
+    if (off > 0)
+        trace_ext_puts(buf);
+}
+
+static void validate_args(uint64_t scn, uint64_t* args) {
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_VALUE:
+            case ARG_HANDLE:
+
+            case ARG_VALUE_OUT_PTR:
+            case ARG_VALUE_INOUT_PTR:
+            case ARG_HANDLE_OUT_PTR: // Upper bits are not used
+                assert((arg_info >> 8) == 0);
+                break;
+
+            case ARG_BUF_IN_ADDR:
+            case ARG_BUF_OUT_ADDR:
+            case ARG_BUF_INOUT_ADDR:
+                //assert(get_buf_size(scn, args, arg_info) != SIZE_MAX);
+                //assert(get_buf_size(scn, args, arg_info) < 1 << 20);
+                break;
+
+            default:
+                EMSG("validate_args(): Unexpected arg type: %x", arg_info);
+                assert(0);
+        }
+    }
+}
+
+static inline bool is_valid_address(void* addr, size_t len) {
+    struct ts_session *s;
+    struct user_ta_ctx *uta_ctx;
+
+    if ((s = ts_get_current_session()) == NULL)
+        assert(0);
+
+    uta_ctx = to_user_ta_ctx(s->ctx);
+    return vm_check_access_rights(&(uta_ctx->uctx),
+                                       TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,
+                                       (uaddr_t)addr, len) == TEE_SUCCESS;
+}
+
+static uint32_t determine_arg_type(struct afl_svc_trace_ctx* ctx, uint64_t scn, uint64_t* args) {
+    uint32_t cmd_arg_type = 0;
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+
+        switch (arg_info & 0xFF) {
+            case ARG_VALUE:
+                SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                break;
+
+            case ARG_HANDLE:
+                // There are a bunch of test cases that use bad handles
+                // Also, in some cases the handle is optional
+                if (has_handle(ctx, args[i])) { 
+                    SET_ARG_TYPE(cmd_arg_type, i, ARG_BUFFER_DEREF32);
+                }
+                else {
+                    SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                }
+                break;
+
+            case ARG_VALUE_OUT_PTR:
+            case ARG_HANDLE_OUT_PTR:
+            case ARG_BUF_OUT_ADDR:
+                {
+                    void* buf_ptr = (void*)args[i];
+                    size_t buf_size = (((arg_info & 0xFF) == ARG_VALUE_OUT_PTR || (arg_info & 0xFF) == ARG_HANDLE_OUT_PTR) ? sizeof(uint64_t) : get_buf_size(scn, args, arg_info));
+
+                    if (is_valid_address(buf_ptr, buf_size) && buf_size) {
+                        if (has_buffer(ctx, (void*)args[i], buf_size)) {
+                            SET_ARG_TYPE(cmd_arg_type, i, ARG_BUFFER_REF);
+                        }
+                        else {
+                            SET_ARG_TYPE(cmd_arg_type, i, ARG_BUFFER_ALLOC);
+                        }
+                    }
+                    else {
+                        EMSG("Ignore invalid address: %p:%x", buf_ptr, buf_size);
+
+                        SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                    }
+                }
+                break;
+
+            case ARG_VALUE_INOUT_PTR:
+            case ARG_BUF_IN_ADDR:
+            case ARG_BUF_INOUT_ADDR:
+                {
+                    void* buf_ptr = (void*)args[i];
+                    size_t buf_size = (((arg_info & 0xFF) == ARG_VALUE_INOUT_PTR) ? sizeof(uint64_t) : get_buf_size(scn, args, arg_info));
+                    
+                    if (is_valid_address(buf_ptr, buf_size) && buf_size) {
+                        if (GET_ARG_BUF_TYPE(arg_info) > 0 && GET_ARG_BUF_TYPE(arg_info) == ARG_TYPE_ATTR) {
+                            uint32_t num_args = 0;
+                            size_t data_size = 0;
+                            size_t data_offset = 0;
+
+                            struct utee_attribute attr = {0};
+
+                            buf_size = get_buf_size(scn, args, arg_info);
+                            num_args = buf_size / sizeof(struct utee_attribute);
+
+                            assert(buf_size % sizeof(struct utee_attribute) == 0);
+                            assert(num_args > 0);
+
+                            if (num_args > 1) /* TODO: multi attr support */
+                                num_args = 1;
+
+                            assert(copy_from_user(&attr, (void*)args[i], sizeof(attr)) == TEE_SUCCESS);
+
+                            if (is_valid_address(attr.a, attr.b) && attr.b) {
+                                SET_ARG_TYPE(cmd_arg_type, i, ARG_TEE_ATTR);
+                            }
+                            else { /* TODO: support attr without addresses */
+                                EMSG("Ignore invalid attr address: %p:%x", buf_ptr, buf_size);
+
+                                SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                            }
+                        }
+                        // Did we see this buffer before?
+                        else if (has_buffer(ctx, (void*)args[i], buf_size)) {
+                            SET_ARG_TYPE(cmd_arg_type, i, ARG_BUFFER_REF);
+                        }
+                        else {
+                            SET_ARG_TYPE(cmd_arg_type, i, ARG_DATA_PRIVATE);
+                        }
+                    }
+                    else {
+                        EMSG("Ignore invalid address: %p:%x", buf_ptr, buf_size);
+
+                        SET_ARG_TYPE(cmd_arg_type, i, ARG_VALUE_32);
+                    }
+                }
+                break;
+
+            default:
+                assert(0);
+        }
+    }
+
+    return cmd_arg_type;
+}
+
+static void append_cmd(struct afl_svc_trace_ctx* ctx, uint64_t scn, uint64_t* args) {
+    uint32_t cmd_arg_type = determine_arg_type(ctx, scn, args);
+
+    uintptr_t cmd_buff_size = (uintptr_t)ctx->cmd_buf_last_append_p - (uintptr_t)ctx->cmd_buf;
+
+/* recommended by AFL. see more: https://afl-1.readthedocs.io/en/latest/tips.html#performance-tips */
+    if (cmd_buff_size > 1024) { // Max 1 kb of commands
+        return;
+    }
+
+    ctx->cmd_buf = realloc(ctx->cmd_buf, cmd_buff_size + max_invoke_entry_size());
+
+    if (ctx->cmd_buf == NULL)
+        return;
+
+    ctx->cmd_buf_last_append_p = (uintptr_t)ctx->cmd_buf + cmd_buff_size;
+    ctx->cmd_buf_last_p = ctx->cmd_buf_last_append_p;   
+
+    CMD_BUF_APPEND(ctx->cmd_buf_last_append_p, scn, cmd_arg_type);
+
+    for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+        uint64_t arg_info = syscall_arg_info(scn, i);
+        uint32_t arg_type = GET_ARG_TYPE(cmd_arg_type, i);
+
+        switch (arg_type) {
+            case ARG_NONE:
+            case ARG_VALUE_NULL:
+                break;
+
+            case ARG_VALUE_32:
+                CMD_BUF_APPEND_ARG_VALUE32(ctx->cmd_buf_last_append_p, args[i]);
+                break;
+
+            case ARG_BUFFER_DEREF32:
+                {
+                    switch (arg_info & 0xFF) {
+                        case ARG_HANDLE:
+                            assert(has_handle(ctx, args[i]));
+
+                            CMD_BUF_APPEND_ARG_DEREF32(ctx->cmd_buf_last_append_p, lookup_handle_buffer_id(ctx, args[i]));
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            case ARG_BUFFER_ALLOC:
+                { // Lookup buffer or assign a new one
+                    size_t buf_size;
+                    uint32_t buf_id;
+
+                    switch (arg_info & 0xFF) {
+                        case ARG_VALUE_INOUT_PTR:
+                        case ARG_VALUE_OUT_PTR:
+                        case ARG_HANDLE_OUT_PTR:
+                            buf_size = sizeof(uint64_t);
+
+                            assert(!has_buffer(ctx, (void*)args[i], buf_size));
+
+                            buf_id = assign_buffer_id(ctx, (void*)args[i], buf_size);
+
+                            CMD_BUF_APPEND_ARG_BUFFER_ALLOC(ctx->cmd_buf_last_append_p, buf_id, buf_size);
+                            break;
+
+                        case ARG_BUF_IN_ADDR:
+                        case ARG_BUF_INOUT_ADDR:
+                        case ARG_BUF_OUT_ADDR:
+                            buf_size = get_buf_size(scn, args, arg_info);
+
+                            assert(!has_buffer(ctx, (void*)args[i], buf_size));
+
+                            buf_id = assign_buffer_id(ctx, (void*)args[i], buf_size);
+
+                            CMD_BUF_APPEND_ARG_BUFFER_ALLOC(ctx->cmd_buf_last_append_p, buf_id, buf_size);
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            case ARG_BUFFER_REF:
+                { // Lookup buffer or assign a new one
+                    size_t buf_size;
+
+                    switch (arg_info & 0xFF) {
+                        case ARG_VALUE_INOUT_PTR:
+                        case ARG_VALUE_OUT_PTR:
+                        case ARG_HANDLE_OUT_PTR:
+                            buf_size = sizeof(uint64_t);
+
+                            assert(has_buffer(ctx, (void*)args[i], buf_size));
+
+                            CMD_BUF_APPEND_ARG_BUFFER_REF(ctx->cmd_buf_last_append_p, lookup_buffer_id(ctx, (void*)args[i], buf_size), buf_size);
+                            break;
+
+                        case ARG_BUF_IN_ADDR:
+                        case ARG_BUF_INOUT_ADDR:
+                        case ARG_BUF_OUT_ADDR:
+                            buf_size = get_buf_size(scn, args, arg_info);
+
+                            assert(has_buffer(ctx, (void*)args[i], buf_size));
+
+                            CMD_BUF_APPEND_ARG_BUFFER_REF(ctx->cmd_buf_last_append_p, lookup_buffer_id(ctx, (void*)args[i], buf_size), buf_size);
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            case ARG_DATA_PRIVATE:
+                { // Copy data + set offset
+                    size_t data_size = 0;
+                    size_t data_offset = 0;
+
+                    assert(args[i] != NULL);
+
+                    switch (arg_info & 0xFF) {
+                        case ARG_VALUE_INOUT_PTR:
+                            data_size = sizeof(uint64_t);
+
+                            data_offset = DATA_BUF_APPEND(ctx->data_buf, (void*)args[i], data_size);
+
+                            CMD_BUF_APPEND_ARG_DATA(ctx->cmd_buf_last_append_p, data_offset, data_size);
+                            break;
+
+                        case ARG_BUF_IN_ADDR:
+                        case ARG_BUF_INOUT_ADDR:
+                            data_size = get_buf_size(scn, args, arg_info);
+
+                            if (data_size > 512) // Even the biggest keys etc should fit in 512 bytes
+                                data_size = 512;
+
+                            data_offset = DATA_BUF_APPEND(ctx->data_buf, (void*)args[i], data_size);
+
+                            CMD_BUF_APPEND_ARG_DATA(ctx->cmd_buf_last_append_p, data_offset, data_size);
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            case ARG_TEE_ATTR:
+                {
+                    uint32_t num_args = 0;
+                    size_t buf_size = 0;
+                    size_t data_size = 0;
+                    size_t data_offset = 0;
+
+                    struct utee_attribute attr = {0};
+
+                    switch (arg_info & 0xFF) {
+                        case ARG_BUF_IN_ADDR:
+                            buf_size = get_buf_size(scn, args, arg_info);
+                            num_args = buf_size / sizeof(struct utee_attribute);
+
+                            assert(buf_size % sizeof(struct utee_attribute) == 0);
+
+                            if (num_args > 1) /* TODO: multi attr support */
+                                num_args = 1;
+
+                            assert(copy_from_user(&attr, (void*)args[i], sizeof(attr)) == TEE_SUCCESS);
+
+                            data_size = attr.b;
+                            data_offset = DATA_BUF_APPEND(ctx->data_buf, attr.a, data_size);
+
+                            CMD_BUF_APPEND_ARG_TEE_ATTR(ctx->cmd_buf_last_append_p, attr.attribute_id, data_offset, data_size);
+                            break;
+
+                        default:
+                            assert(0);
+                    }
+                }
+                break;
+
+            default:
+                EMSG("Unexpected arg type: %x", arg_type);
+                assert(0);
+        }
+    }
+}  
+
+static void dump_args(uint64_t* args) {
+    for (int i = 0; i < 8; i++) {
+        EMSG("args[%d] = %p\n", i, args[i]);
+    }
+}
+
+static void do_svc_log_call(struct afl_svc_trace_ctx* ctx, uint64_t scn, uint64_t* args) {
+    print_invoke_syscall_info(scn, args);
+
+    validate_args(scn, args);
+
+    append_cmd(ctx, scn, args);
+}
+
+static void do_svc_log_call_post(struct afl_svc_trace_ctx* ctx, uint64_t scn, const uint64_t* args, uint32_t ret_val) {
+    print_post_invoke_syscall_info(scn, args, ret_val);
+
+    if (ret_val == TEE_SUCCESS) {
+        track_created_handles(ctx, scn, args);
+    }
+
+}
+
+static uint64_t get_reg_val(const struct thread_svc_regs *regs, uint32_t reg_nr) {
+    uint64_t val = 0;
+
+    switch (reg_nr) {
+        #define __SW_CASE(n) \
+                case n: \
+                    val = regs->x ## n; \
+                    break;
+
+        __SW_CASE(0);
+        __SW_CASE(1);
+        __SW_CASE(2);
+        __SW_CASE(3);
+        __SW_CASE(4);
+        __SW_CASE(5);
+        __SW_CASE(6);
+        __SW_CASE(7);
+
+        default:
+            assert(0);
+    }
+
+    return val;
+}
+
+static bool is_svc_ignored(uint64_t scn) {
+    switch (scn) {
+        case TEE_SCN_RETURN:
+        case TEE_SCN_PANIC:
+        case TEE_SCN_LOG:
+        case TEE_SCN_WAIT:
+
+        case TEE_SCN_OPEN_TA_SESSION:
+        case TEE_SCN_CLOSE_TA_SESSION:
+        case TEE_SCN_INVOKE_TA_COMMAND:
+
+        /* too noisy for demos */
+        case TEE_SCN_CRYP_OBJ_GET_INFO:
+            return true;
+
+        default:
+            return false;
+    }
+}
+
+/* Called from arch_svc.c */
+void __afl_svc_trace_log_call(uint64_t scn, struct thread_svc_regs *regs, uint64_t* args) {
+    struct ts_session *sess;
+
+    assert((sess = ts_get_current_session()) != NULL);
+
+    if (sess->svc_trace_ctx != NULL && sess->svc_trace_ctx->trace_enabled) {
+        if (!is_svc_ignored(scn)) {
+            for (uint32_t i = 0; i < syscall_num_args(scn); i++) {
+                args[i] = get_reg_val(regs, i);
+            }
+
+            do_svc_log_call(sess->svc_trace_ctx, scn, args);
+        }
+    }
+}
+
+void __afl_svc_trace_log_call_post(uint64_t scn, const struct thread_svc_regs *regs, const uint64_t* args) {
+    struct ts_session *sess;
+
+    assert((sess = ts_get_current_session()) != NULL);
+
+    if (sess->svc_trace_ctx != NULL && sess->svc_trace_ctx->trace_enabled) {
+        if (!is_svc_ignored(scn)) {
+            do_svc_log_call_post(sess->svc_trace_ctx, scn, args, regs->x0);
+        }
+    }
+}
+
+static inline void update_data_offsets(void* buf, uint32_t buf_len, uint32_t data_offset) {
+    CTX ctx = {
+        .buf = buf,
+        .buf_len = buf_len,
+
+        .cmd_first = buf,
+        .cmd_current = NULL,
+
+        .data = buf,
+        .data_len = buf_len,
+
+        .p_error = NULL
+    };
+
+    while (CMD_NEXT(&ctx) != NULL) {
+        const SYSCALL_INVOKE* const sys_invoke_p = CMD_CURRENT(&ctx);
+
+        SVC_FOREACH_ARG(sys_invoke_p, 0, syscall_num_args(sys_invoke_p->nr), p_arg, arg_type, {
+            switch (arg_type) {
+                case ARG_DATA_SHARED:
+                case ARG_DATA_PRIVATE:
+                    ((SYSCALL_ARG*)p_arg)->data.offset += data_offset;
+                    break;
+
+                case ARG_TEE_ATTR:
+                    ((SYSCALL_ARG*)p_arg)->tee_attr.offset += data_offset;
+                    break;
+
+                default:
+                    break;
+            }
+        });
+    }
+}
+
+/* located at: core/tee/entry_std.c */
+extern struct tee_ta_session_head tee_open_sessions;
+
+/* Called by AFL-TEE PTA */
+TEE_Result afl_svc_trace_start(uint32_t session_id) {
+    struct tee_ta_session* ta_sess;
+    struct ts_session* sess;
+
+    ta_sess = tee_ta_get_session(session_id, true, &tee_open_sessions);
+    if (ta_sess == NULL)
+        return TEE_ERROR_BAD_PARAMETERS;
+
+    EMSG("Start tracing... (ta_sess_id: %x)", session_id);
+
+    sess = &(ta_sess->ts_sess);    
+
+    if (!sess->svc_trace_ctx) {
+        sess->svc_trace_ctx = (struct afl_svc_trace_ctx*)malloc(sizeof(struct afl_svc_trace_ctx));
+
+        memset(sess->svc_trace_ctx, 0, sizeof(struct afl_svc_trace_ctx));
+    }
+
+    struct afl_svc_trace_ctx* ctx = sess->svc_trace_ctx;
+
+    assert(ctx != NULL);
+    assert(!ctx->trace_enabled);
+
+    ctx->trace_enabled = true;
+
+    tee_ta_put_session(ta_sess);
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result afl_svc_trace_stop(uint32_t session_id, void* dst, uint32_t* dst_len) {
+    struct tee_ta_session* ta_sess;
+    struct ts_session* sess;
+
+    ta_sess = tee_ta_get_session(session_id, true, &tee_open_sessions);
+    if (sess == NULL)
+        return TEE_ERROR_BAD_PARAMETERS;
+
+    EMSG("Stop tracing... (sess_id: %x)", session_id);
+
+    sess = &(ta_sess->ts_sess);    
+
+    struct afl_svc_trace_ctx* ctx = sess->svc_trace_ctx;
+
+    assert(ctx != NULL);
+    assert(ctx->trace_enabled);
+
+    ctx->trace_enabled = false;
+
+    if (CMD_BUF_SIZE(ctx->cmd_buf)) {
+        assert(ctx->cmd_buf != NULL);
+        assert(ctx->cmd_buf_last_append_p != NULL);
+
+        // Terminate command buffer
+        CMD_BUF_APPEND(ctx->cmd_buf_last_append_p, 0xFF, 0);
+
+        size_t cmd_len = CMD_BUF_SIZE(ctx->cmd_buf);
+        size_t data_len = DATA_BUF_SIZE(ctx->data_buf);
+
+        EMSG("Cmd len %x Data len %x", cmd_len, data_len);
+
+        if (cmd_len + data_len > *dst_len) {
+            return TEE_ERROR_BAD_PARAMETERS;
+        }
+
+        update_data_offsets(ctx->cmd_buf, cmd_len, cmd_len);
+
+        memcpy(dst, ctx->cmd_buf, cmd_len);
+
+        if (data_len) {
+            assert(ctx->data_buf != NULL);
+
+            memcpy((void*)((uintptr_t) dst + cmd_len), ctx->data_buf, data_len);
+        }
+
+        *dst_len = cmd_len + data_len;
+    }
+    else {
+        *dst_len = 0;
+    }
+
+    tee_ta_put_session(ta_sess);
+
+    return TEE_SUCCESS;
+}
+
+TEE_Result afl_trace_init(void)
+{
+    __cache_data();
+
+    return TEE_SUCCESS;
+}
+
+driver_init(afl_trace_init);
\ No newline at end of file
diff --git a/core/kernel/assert.c b/core/kernel/assert.c
index 1d2e3c934..543decb50 100644
--- a/core/kernel/assert.c
+++ b/core/kernel/assert.c
@@ -6,6 +6,7 @@
 #include <assert.h>
 #include <compiler.h>
 #include <trace.h>
+#include <kernel/afl.h>
 #include <kernel/panic.h>
 
 /* assert log and break for the optee kernel */
@@ -15,6 +16,7 @@ void __nostackcheck _assert_log(const char *expr __maybe_unused,
 				const int line __maybe_unused,
 				const char *func __maybe_unused)
 {
+	__afl_set_ctx_ptr(0);
 #if defined(CFG_TEE_CORE_DEBUG)
 	EMSG_RAW("assertion '%s' failed at %s:%d <%s>",
 		 expr, file, line, func);
diff --git a/core/kernel/panic.c b/core/kernel/panic.c
index f30c6ffe7..8408a197f 100644
--- a/core/kernel/panic.c
+++ b/core/kernel/panic.c
@@ -4,6 +4,7 @@
  * Copyright (c) 2014, STMicroelectronics International N.V.
  */
 
+#include <kernel/afl.h>
 #include <kernel/panic.h>
 #include <kernel/thread.h>
 #include <kernel/unwind.h>
@@ -14,6 +15,9 @@ void __do_panic(const char *file __maybe_unused,
 		const char *func __maybe_unused,
 		const char *msg __maybe_unused)
 {
+#ifdef CFG_AFL_ENABLE
+	__afl_set_ctx_ptr(0);
+#endif
 	/* disable prehemption */
 	(void)thread_mask_exceptions(THREAD_EXCP_ALL);
 
@@ -30,6 +34,15 @@ void __do_panic(const char *file __maybe_unused,
 
 	print_kernel_stack();
 	/* abort current execution */
+#ifdef CFG_AFL_ENABLE
+	struct ts_session *sess;
+
+    if ((sess = ts_get_current_session()) != NULL && sess->afl_ctx && sess->afl_ctx->enabled) {
+    	EMSG_RAW("AFL Input:");
+        //hexdump(sess->afl_ctx->input, sess->afl_ctx->input_len);
+        dhex_dump(NULL, 0, 0, sess->afl_ctx->input, sess->afl_ctx->input_len);
+    }
+#endif
 	while (1)
 		;
 }
diff --git a/core/kernel/ree_fs_ta.c b/core/kernel/ree_fs_ta.c
index e61569a2b..2f5c7a54c 100644
--- a/core/kernel/ree_fs_ta.c
+++ b/core/kernel/ree_fs_ta.c
@@ -131,7 +131,9 @@ static TEE_Result ree_fs_ta_open(const TEE_UUID *uuid,
 	struct ree_fs_ta_handle *handle;
 	struct shdr *shdr = NULL;
 	struct mobj *mobj = NULL;
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	void *hash_ctx = NULL;
+#endif
 	struct shdr *ta = NULL;
 	size_t ta_size = 0;
 	TEE_Result res;
@@ -169,6 +171,7 @@ static TEE_Result ree_fs_ta_open(const TEE_UUID *uuid,
 	 * Initialize a hash context and run the algorithm over the signed
 	 * header (less the final file hash and its signature of course)
 	 */
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	res = crypto_hash_alloc_ctx(&hash_ctx,
 				    TEE_DIGEST_HASH_TO_ALGO(shdr->algo));
 	if (res != TEE_SUCCESS)
@@ -179,6 +182,7 @@ static TEE_Result ree_fs_ta_open(const TEE_UUID *uuid,
 	res = crypto_hash_update(hash_ctx, (uint8_t *)shdr, sizeof(*shdr));
 	if (res != TEE_SUCCESS)
 		goto error_free_hash;
+#endif
 	offs = SHDR_GET_SIZE(shdr);
 
 	if (shdr->img_type == SHDR_BOOTSTRAP_TA ||
@@ -210,10 +214,12 @@ static TEE_Result ree_fs_ta_open(const TEE_UUID *uuid,
 			goto error_free_hash;
 		}
 
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 		res = crypto_hash_update(hash_ctx, (uint8_t *)bs_hdr,
 					 sizeof(*bs_hdr));
 		if (res != TEE_SUCCESS)
 			goto error_free_hash;
+#endif
 		offs += sizeof(*bs_hdr);
 		handle->bs_hdr = bs_hdr;
 	}
@@ -238,10 +244,12 @@ static TEE_Result ree_fs_ta_open(const TEE_UUID *uuid,
 		memcpy(ehdr, ((uint8_t *)ta + offs),
 		       SHDR_ENC_GET_SIZE(&img_ehdr));
 
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 		res = crypto_hash_update(hash_ctx, (uint8_t *)ehdr,
 					 SHDR_ENC_GET_SIZE(ehdr));
 		if (res != TEE_SUCCESS)
 			goto error_free_hash;
+#endif
 
 		res = tee_ta_decrypt_init(&handle->enc_ctx, ehdr,
 					  shdr->img_size);
@@ -260,14 +268,18 @@ static TEE_Result ree_fs_ta_open(const TEE_UUID *uuid,
 	handle->nw_ta = ta;
 	handle->nw_ta_size = ta_size;
 	handle->offs = offs;
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	handle->hash_ctx = hash_ctx;
+#endif
 	handle->shdr = shdr;
 	handle->mobj = mobj;
 	*h = (struct ts_store_handle *)handle;
 	return TEE_SUCCESS;
 
 error_free_hash:
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	crypto_hash_free_ctx(hash_ctx);
+#endif
 error_free_payload:
 	thread_rpc_free_payload(mobj);
 error:
@@ -428,6 +440,7 @@ static TEE_Result ree_fs_ta_read(struct ts_store_handle *h, void *data,
 		return TEE_ERROR_BAD_PARAMETERS;
 
 	if (handle->shdr->img_type == SHDR_ENCRYPTED_TA) {
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 		if (data) {
 			dst = data; /* Hash secure buffer */
 			res = tee_ta_decrypt_update(handle->enc_ctx, dst, src,
@@ -462,18 +475,22 @@ static TEE_Result ree_fs_ta_read(struct ts_store_handle *h, void *data,
 			if (res != TEE_SUCCESS)
 				return TEE_ERROR_SECURITY;
 		}
+#endif
 	} else if (data) {
 		dst = data; /* Hash secure buffer (shm might be modified) */
 		memcpy(dst, src, len);
 	}
 
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	if (dst) {
 		res = crypto_hash_update(handle->hash_ctx, dst, len);
 		if (res != TEE_SUCCESS)
 			return TEE_ERROR_SECURITY;
 	}
+#endif
 
 	handle->offs = next_offs;
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	if (handle->offs == handle->nw_ta_size) {
 		if (handle->shdr->img_type == SHDR_ENCRYPTED_TA) {
 			/*
@@ -497,6 +514,9 @@ static TEE_Result ree_fs_ta_read(struct ts_store_handle *h, void *data,
 			res = check_update_version(handle->bs_hdr);
 	}
 	return res;
+#else
+	return TEE_SUCCESS;
+#endif
 }
 
 static void ree_fs_ta_close(struct ts_store_handle *h)
@@ -506,7 +526,9 @@ static void ree_fs_ta_close(struct ts_store_handle *h)
 	if (!handle)
 		return;
 	thread_rpc_free_payload(handle->mobj);
+#ifndef CFG_AFL_SKIP_TA_AUTHENTICATION
 	crypto_hash_free_ctx(handle->hash_ctx);
+#endif
 	free(handle->shdr);
 	free(handle->ehdr);
 	free(handle->bs_hdr);
diff --git a/core/kernel/sub.mk b/core/kernel/sub.mk
index a5dfae22f..daf26910b 100644
--- a/core/kernel/sub.mk
+++ b/core/kernel/sub.mk
@@ -37,3 +37,42 @@ endif
 
 srcs-$(CFG_EMBEDDED_TS) += embedded_ts.c
 srcs-y += pseudo_ta.c
+srcs-$(CFG_AFL_ENABLE) += afl_helper.S
+srcs-$(CFG_AFL_ENABLE) += afl.c
+srcs-$(CFG_AFL_ENABLE) += afl_svc_trace.c
+
+cflags-afl_helper.S-y += -fno-sanitize=all
+cflags-afl.c-y += -fno-sanitize=all
+cflags-asan.c-y += -fno-sanitize=all 
+cflags-assert.c-y += -fno-sanitize=all 
+cflags-console.c-y += -fno-sanitize=all 
+cflags-interrupt.c-y += -fno-sanitize=all 
+cflags-msg_param.c-y += -fno-sanitize=all 
+cflags-panic.c-y += -fno-sanitize=all 
+cflags-refcount.c-y += -fno-sanitize=all 
+cflags-tee_ta_manager.c-y += -fno-sanitize=all 
+cflags-ubsan.c-y += -fno-sanitize=all 
+
+cflags-afl_svc_trace.c-y += -I../afl-tee/shared/include
+cflags-afl_svc_trace.c-y += -Wno-pedantic -Wno-discarded-qualifiers -Wno-missing-prototypes -Wno-switch-default
+cflags-afl_svc_trace.c-y += -Wno-unused-parameter -Wno-missing-declarations -Wno-declaration-after-statement -Wno-format
+
+cflags-remove-afl_helper.S-y += -fsanitize-coverage=trace-pc
+cflags-remove-afl.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-afl_svc_trace.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-asan.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-assert.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-console.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-interrupt.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-msg_param.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-panic.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-refcount.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_misc.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-tee_ta_manager.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-ubsan.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-pseudo_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-ree_fs_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-secstor_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-early_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-user_ta.c-y += -fsanitize-coverage=trace-pc
+cflags-remove-wait_queue.c-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/kernel/tee_ta_manager.c b/core/kernel/tee_ta_manager.c
index a15304161..6e1095353 100644
--- a/core/kernel/tee_ta_manager.c
+++ b/core/kernel/tee_ta_manager.c
@@ -7,6 +7,7 @@
 #include <arm.h>
 #endif
 #include <assert.h>
+#include <kernel/afl.h>
 #include <kernel/mutex.h>
 #include <kernel/panic.h>
 #include <kernel/pseudo_ta.h>
@@ -529,6 +530,32 @@ TEE_Result tee_ta_close_session(struct tee_ta_session *csess,
 		return TEE_ERROR_BAD_PARAMETERS; /* intentional generic error */
 	}
 
+#if defined(CFG_AFL_ENABLE)
+	struct ts_session *ts_sess = &(sess->ts_sess);
+
+	if (ts_sess->afl_ctx) {
+		free(ts_sess->afl_ctx);
+		
+		ts_sess->afl_ctx = NULL;
+	}
+
+	if (ts_sess->svc_trace_ctx) {
+		// log buffers
+		ts_sess->svc_trace_ctx->cmd_buf = (ts_sess->svc_trace_ctx->cmd_buf) ? free(ts_sess->svc_trace_ctx->cmd_buf), NULL : NULL;
+		ts_sess->svc_trace_ctx->data_buf = (ts_sess->svc_trace_ctx->data_buf) ? free(ts_sess->svc_trace_ctx->data_buf), NULL : NULL;
+
+		// buffer ids
+		ts_sess->svc_trace_ctx->buf_ptrs = (ts_sess->svc_trace_ctx->buf_ptrs) ? free(ts_sess->svc_trace_ctx->buf_ptrs), NULL : NULL;
+		ts_sess->svc_trace_ctx->buf_sizes = (ts_sess->svc_trace_ctx->buf_sizes) ? free(ts_sess->svc_trace_ctx->buf_sizes), NULL : NULL;
+
+		// handles
+		ts_sess->svc_trace_ctx->handles = (ts_sess->svc_trace_ctx->handles) ? free(ts_sess->svc_trace_ctx->handles), NULL : NULL;
+		ts_sess->svc_trace_ctx->handle_buf_ids = (ts_sess->svc_trace_ctx->handle_buf_ids) ? free(ts_sess->svc_trace_ctx->handle_buf_ids), NULL : NULL;
+
+		ts_sess->svc_trace_ctx = (free(ts_sess->svc_trace_ctx), NULL);
+	}
+#endif
+
 	DMSG("Destroy session");
 
 	ts_ctx = sess->ts_sess.ctx;
diff --git a/core/kernel/ubsan.c b/core/kernel/ubsan.c
index 04b016383..72ae6828b 100644
--- a/core/kernel/ubsan.c
+++ b/core/kernel/ubsan.c
@@ -28,6 +28,21 @@ struct type_mismatch_data {
 	unsigned char type_check_kind;
 };
 
+struct type_mismatch_data_v1 {
+	struct source_location loc;
+	struct type_descriptor *type;
+	unsigned char log_alignment;
+	unsigned char type_check_kind;
+};
+
+struct pointer_overflow_data {
+	struct source_location loc;
+};
+
+struct invalid_builtin_data {
+	struct source_location loc;
+};
+
 struct overflow_data {
 	struct source_location loc;
 	struct type_descriptor *type;
@@ -70,6 +85,11 @@ struct nonnull_arg_data {
  */
 void __ubsan_handle_type_mismatch(struct type_mismatch_data *data,
 				  unsigned long ptr);
+void __ubsan_handle_type_mismatch_v1(struct type_mismatch_data_v1 *data,
+				  unsigned long ptr __unused);
+void __ubsan_handle_pointer_overflow(struct pointer_overflow_data *data,
+				  unsigned long base __unused, unsigned long result __unused);
+void __ubsan_handle_invalid_builtin(struct invalid_builtin_data *data);
 void __ubsan_handle_add_overflow(struct overflow_data *data,
 				  unsigned long lhs, unsigned long rhs);
 void __ubsan_handle_sub_overflow(struct overflow_data *data,
@@ -119,6 +139,28 @@ void __ubsan_handle_type_mismatch(struct type_mismatch_data *data,
 		panic();
 }
 
+void __ubsan_handle_type_mismatch_v1(struct type_mismatch_data_v1 *data,
+				  unsigned long ptr __unused)
+{
+	print_loc(__func__, &data->loc);
+	if (ubsan_panic)
+		panic();
+}
+
+void __ubsan_handle_pointer_overflow(struct pointer_overflow_data *data,
+				  unsigned long base __unused, unsigned long result __unused)
+{
+	print_loc(__func__, &data->loc);
+	if (ubsan_panic)
+		panic();
+}
+
+void __ubsan_handle_invalid_builtin(struct invalid_builtin_data *data) {
+	print_loc(__func__, &data->loc);
+	if (ubsan_panic)
+		panic();
+}
+
 void __ubsan_handle_add_overflow(struct overflow_data *data,
 				 unsigned long lhs __unused,
 				 unsigned long rhs __unused)
diff --git a/core/lib/libtomcrypt/sub.mk b/core/lib/libtomcrypt/sub.mk
index 509f3b9f2..21093abe1 100644
--- a/core/lib/libtomcrypt/sub.mk
+++ b/core/lib/libtomcrypt/sub.mk
@@ -140,3 +140,5 @@ endif
 
 srcs-y += tomcrypt.c
 
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/core/mm/sub.mk b/core/mm/sub.mk
index 7c0f4bf20..ac2be5179 100644
--- a/core/mm/sub.mk
+++ b/core/mm/sub.mk
@@ -2,3 +2,6 @@ srcs-y += mobj.c
 srcs-y += fobj.c
 srcs-y += file.c
 srcs-y += vm.c
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/core/pta/afl.c b/core/pta/afl.c
new file mode 100644
index 000000000..6bc68a13a
--- /dev/null
+++ b/core/pta/afl.c
@@ -0,0 +1,114 @@
+#include <compiler.h>
+#include <stdio.h>
+#include <trace.h>
+#include <kernel/pseudo_ta.h>
+#include <mm/tee_pager.h>
+#include <mm/tee_mm.h>
+#include <string.h>
+#include <string_ext.h>
+#include <malloc.h>
+#include <kernel/afl.h>
+
+#define TA_NAME         "afl.ta"
+
+#define AFL_UUID { 0xd96a5b41, 0xe2c8, 0xb1af, { 0x87, 0x94, 0x10, 0x03, 0xa5, 0xd5, 0xc7, 0x1b } }
+
+#define AFL_PTA_CMD_ENABLE_SVC_TRACE            0
+#define AFL_PTA_CMD_DISABLE_SVC_TRACE           1
+#define AFL_PTA_CMD_COPY_FULL_MAP               2
+#define AFL_PTA_CMD_RESET_FULL_MAP              3
+
+
+static TEE_Result enable_svc_trace(uint32_t type, TEE_Param p[TEE_NUM_PARAMS])
+{
+    if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE) != type) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    DMSG("Enable SVC tracing for session %x", p[0].value.a);
+
+    return afl_svc_trace_start(p[0].value.a);
+}
+
+static TEE_Result disable_svc_trace(uint32_t type, TEE_Param p[TEE_NUM_PARAMS])
+{
+    if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_VALUE_INPUT,
+                        TEE_PARAM_TYPE_MEMREF_OUTPUT,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE) != type) {
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    DMSG("Disable SVC tracing for session %x", p[0].value.a);
+
+    return afl_svc_trace_stop(p[0].value.a, p[1].memref.buffer, &p[1].memref.size);
+}
+
+#ifdef AFL_FULL_MAP
+static TEE_Result copy_full_map(uint32_t type, TEE_Param p[TEE_NUM_PARAMS])
+{
+    if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_MEMREF_OUTPUT,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE) != type) {
+        EMSG("expect 1 output values as argument");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    if (p[0].memref.size < FULL_MAP_SIZE) {
+        EMSG("Output buffer too small");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    afl_copy_full_map(p[0].memref.buffer, &p[0].memref.size);
+
+    return TEE_SUCCESS;
+}
+
+static TEE_Result reset_full_map(uint32_t type, TEE_Param p[TEE_NUM_PARAMS])
+{
+    if (TEE_PARAM_TYPES(TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE,
+                        TEE_PARAM_TYPE_NONE) != type) {
+        EMSG("expect no arguments");
+        return TEE_ERROR_BAD_PARAMETERS;
+    }
+
+    afl_reset_full_map();
+
+    return TEE_SUCCESS;
+}
+#endif
+
+/*
+ * Trusted Application Entry Points
+ */
+
+static TEE_Result invoke_command(void *psess __unused,
+                                 uint32_t cmd, uint32_t ptypes,
+                                 TEE_Param params[TEE_NUM_PARAMS])
+{
+    switch (cmd) {
+        case AFL_PTA_CMD_ENABLE_SVC_TRACE:
+            return enable_svc_trace(ptypes, params);
+        case AFL_PTA_CMD_DISABLE_SVC_TRACE:
+            return disable_svc_trace(ptypes, params);
+#ifdef AFL_FULL_MAP
+        case AFL_PTA_CMD_COPY_FULL_MAP:
+            return copy_full_map(ptypes, params);
+        case AFL_PTA_CMD_RESET_FULL_MAP:
+            return reset_full_map(ptypes, params);
+#endif
+        default:
+            break;
+    }
+    return TEE_ERROR_BAD_PARAMETERS;
+}
+
+pseudo_ta_register(.uuid = AFL_UUID, .name = TA_NAME,
+                   .flags = PTA_DEFAULT_FLAGS,
+                   .invoke_command_entry_point = invoke_command);
\ No newline at end of file
diff --git a/core/pta/sub.mk b/core/pta/sub.mk
index 78c32f853..58bcf10a4 100644
--- a/core/pta/sub.mk
+++ b/core/pta/sub.mk
@@ -10,5 +10,9 @@ srcs-$(CFG_WITH_STATS) += stats.c
 srcs-$(CFG_SYSTEM_PTA) += system.c
 srcs-$(CFG_NXP_SE05X) += scp03.c
 srcs-$(CFG_SCMI_PTA) += scmi.c
+srcs-$(CFG_AFL_ENABLE) += afl.c
 
 subdirs-y += bcm
+
+cflags-afl.c-y += -fno-sanitize=all
+cflags-remove-afl.c-y += -fsanitize-coverage=trace-pc
diff --git a/core/tee/entry_std.c b/core/tee/entry_std.c
index 1d70273d2..797df1105 100644
--- a/core/tee/entry_std.c
+++ b/core/tee/entry_std.c
@@ -28,7 +28,7 @@
 	(uint32_t)(core_mmu_is_shm_cached() ?  OPTEE_SMC_SHM_CACHED : 0)
 
 /* Sessions opened from normal world */
-static struct tee_ta_session_head tee_open_sessions =
+struct tee_ta_session_head tee_open_sessions =
 TAILQ_HEAD_INITIALIZER(tee_open_sessions);
 
 #ifdef CFG_CORE_RESERVED_SHM
diff --git a/core/tee/sub.mk b/core/tee/sub.mk
index 24046a5d8..202e58f6d 100644
--- a/core/tee/sub.mk
+++ b/core/tee/sub.mk
@@ -47,3 +47,5 @@ endif #CFG_WITH_USER_TA,y
 
 srcs-y += uuid.c
 srcs-y += tee_supp_plugin_rpc.c
+
+cflags-remove-uuid.c-y += -fsanitize-coverage=trace-pc
\ No newline at end of file
diff --git a/ldelf/sub.mk b/ldelf/sub.mk
index 1de7c7954..436f7763e 100644
--- a/ldelf/sub.mk
+++ b/ldelf/sub.mk
@@ -12,3 +12,6 @@ srcs-y += sys.c
 srcs-y += ta_elf.c
 srcs-y += ta_elf_rel.c
 srcs-$(CFG_FTRACE_SUPPORT) += ftrace.c
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libdl/sub.mk b/lib/libdl/sub.mk
index ec9465605..e0716acc0 100644
--- a/lib/libdl/sub.mk
+++ b/lib/libdl/sub.mk
@@ -1,2 +1,5 @@
 global-incdirs-y += include
 srcs-y += dlfcn.c
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libunw/sub.mk b/lib/libunw/sub.mk
index bbb7e912d..532311445 100644
--- a/lib/libunw/sub.mk
+++ b/lib/libunw/sub.mk
@@ -3,3 +3,6 @@ ifeq ($(CFG_UNWIND),y)
 srcs-y += unwind_arm32.c
 srcs-$(CFG_ARM64_$(sm)) += unwind_arm64.c
 endif
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libutee/arch/x86_64/sub.mk b/lib/libutee/arch/x86_64/sub.mk
index e7c7c7f3c..fe885a634 100644
--- a/lib/libutee/arch/x86_64/sub.mk
+++ b/lib/libutee/arch/x86_64/sub.mk
@@ -8,3 +8,4 @@ srcs-y += user_ta_entry.c
 subdirs-y += gprof
 endif #$(sm-$(sm)-is-ld)
 
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libutee/arch/x86_64/utee_syscalls_asm.S b/lib/libutee/arch/x86_64/utee_syscalls_asm.S
index 2b9d9c89a..08a389bfa 100644
--- a/lib/libutee/arch/x86_64/utee_syscalls_asm.S
+++ b/lib/libutee/arch/x86_64/utee_syscalls_asm.S
@@ -121,4 +121,50 @@
         UTEE_SYSCALL _utee_cryp_obj_generate_key, \
                      TEE_SCN_CRYP_OBJ_GENERATE_KEY, 4
 
+        UTEE_SYSCALL _utee_se_service_open, TEE_SCN_SE_SERVICE_OPEN__DEPRECATED, 1
+
+        UTEE_SYSCALL _utee_se_service_close, TEE_SCN_SE_SERVICE_CLOSE__DEPRECATED, 1
+
+        UTEE_SYSCALL _utee_se_service_get_readers, \
+                TEE_SCN_SE_SERVICE_GET_READERS__DEPRECATED, 3
+
+        UTEE_SYSCALL _utee_se_reader_get_prop, \
+                TEE_SCN_SE_READER_GET_PROP__DEPRECATED, 2 
+
+        UTEE_SYSCALL _utee_se_reader_get_name, \
+                TEE_SCN_SE_READER_GET_NAME__DEPRECATED, 3
+
+        UTEE_SYSCALL _utee_se_reader_open_session, \
+                TEE_SCN_SE_READER_OPEN_SESSION__DEPRECATED, 2
+
+        UTEE_SYSCALL _utee_se_reader_close_sessions, \
+                TEE_SCN_SE_READER_CLOSE_SESSIONS__DEPRECATED, 1
+
+        UTEE_SYSCALL _utee_se_session_is_closed, \
+                TEE_SCN_SE_SESSION_IS_CLOSED__DEPRECATED, 1
+
+        UTEE_SYSCALL _utee_se_session_get_atr, \
+                TEE_SCN_SE_SESSION_GET_ATR__DEPRECATED, 3
+
+        UTEE_SYSCALL _utee_se_session_open_channel, \
+                TEE_SCN_SE_SESSION_OPEN_CHANNEL__DEPRECATED, 5
+
+        UTEE_SYSCALL _utee_se_session_close, \
+                TEE_SCN_SE_SESSION_CLOSE__DEPRECATED, 1
+
+        UTEE_SYSCALL _utee_se_channel_select_next, \
+                TEE_SCN_SE_CHANNEL_SELECT_NEXT__DEPRECATED, 1
+
+        UTEE_SYSCALL _utee_se_channel_get_select_resp, \
+                TEE_SCN_SE_CHANNEL_GET_SELECT_RESP__DEPRECATED, 3
+
+        UTEE_SYSCALL _utee_se_channel_transmit, \
+                TEE_SCN_SE_CHANNEL_TRANSMIT__DEPRECATED, 5
+
+        UTEE_SYSCALL _utee_se_channel_close, \
+                TEE_SCN_SE_CHANNEL_CLOSE__DEPRECATED, 1
+
         UTEE_SYSCALL _utee_cache_operation, TEE_SCN_CACHE_OPERATION, 3
+
+        UTEE_SYSCALL utee_afl_cov_bitmap_init, (TEE_SCN_MAX+1), 0
+        UTEE_SYSCALL utee_afl_cov_bitmap_shutdown, (TEE_SCN_MAX+2), 0
diff --git a/lib/libutee/include/utee_syscalls.h b/lib/libutee/include/utee_syscalls.h
index add095b05..6ab7acc3d 100644
--- a/lib/libutee/include/utee_syscalls.h
+++ b/lib/libutee/include/utee_syscalls.h
@@ -288,4 +288,10 @@ TEE_Result _utee_cache_operation(void *va, size_t l, unsigned long op);
 
 TEE_Result _utee_gprof_send(void *buf, size_t size, uint32_t *id);
 
+#ifdef CFG_AFL_ENABLE
+void utee_afl_cov_bitmap_init(void* input, size_t input_len);
+
+void utee_afl_cov_bitmap_shutdown(void* ptr);
+#endif
+
 #endif /* UTEE_SYSCALLS_H */
diff --git a/lib/libutee/sub.mk b/lib/libutee/sub.mk
index 266ff49bb..d4950d59c 100644
--- a/lib/libutee/sub.mk
+++ b/lib/libutee/sub.mk
@@ -19,3 +19,5 @@ srcs-y += tee_tcpudp_socket.c
 endif #ifneq ($(sm),ldelf)
 
 subdirs-y += arch/$(ARCH)
+
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libutils/ext/arch/x86_64/sub.mk b/lib/libutils/ext/arch/x86_64/sub.mk
index fe6571590..107128137 100644
--- a/lib/libutils/ext/arch/x86_64/sub.mk
+++ b/lib/libutils/ext/arch/x86_64/sub.mk
@@ -1,2 +1,5 @@
 srcs-y += auxval.c
 srcs-y += atomic_64.S
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libutils/ext/sub.mk b/lib/libutils/ext/sub.mk
index cb51cf692..24f55dec6 100644
--- a/lib/libutils/ext/sub.mk
+++ b/lib/libutils/ext/sub.mk
@@ -11,3 +11,6 @@ srcs-y += memzero_explicit.c
 
 subdirs-y += arch/$(ARCH)
 subdirs-y += ftrace
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libutils/isoc/arch/x86_64/sub.mk b/lib/libutils/isoc/arch/x86_64/sub.mk
index f06f08516..0c1745c0e 100644
--- a/lib/libutils/isoc/arch/x86_64/sub.mk
+++ b/lib/libutils/isoc/arch/x86_64/sub.mk
@@ -1 +1,4 @@
 srcs-y += setjmp_64.S
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libutils/isoc/newlib/sub.mk b/lib/libutils/isoc/newlib/sub.mk
index d09974ca4..fa2811529 100644
--- a/lib/libutils/isoc/newlib/sub.mk
+++ b/lib/libutils/isoc/newlib/sub.mk
@@ -25,3 +25,8 @@ srcs-y += strnlen.c
 srcs-y += strrchr.c
 srcs-y += strstr.c
 srcs-y += strtoul.c
+
+cflags-y += -fno-sanitize=all 
+cflags-remove-y += -fsanitize-coverage=trace-pc
+
+#cflags-y += -fsanitize-coverage=trace-pc
diff --git a/lib/libutils/isoc/stack_check.c b/lib/libutils/isoc/stack_check.c
index 2a0b2a802..f8f6736fa 100644
--- a/lib/libutils/isoc/stack_check.c
+++ b/lib/libutils/isoc/stack_check.c
@@ -2,6 +2,18 @@
 /*
  * Copyright (c) 2014, STMicroelectronics International N.V.
  */
+#ifdef __KERNEL__
+#include <kernel/panic.h>
+#else
+#include <tee_api.h>
+#include <trace.h>
+
+#define panic(m) \
+	EMSG(m); \
+	TEE_Panic(TEE_ERROR_OVERFLOW);
+	
+#endif
+
 #include <compiler.h>
 void *__stack_chk_guard __nex_data = (void *)0x00000aff;
 
@@ -9,7 +21,6 @@ void __attribute__((noreturn)) __stack_chk_fail(void);
 
 void __stack_chk_fail(void)
 {
-	while (1)
-		;
+	panic("Stack canary corrupted");
 }
 
diff --git a/lib/libutils/isoc/sub.mk b/lib/libutils/isoc/sub.mk
index ef1ca5da8..da87d3448 100644
--- a/lib/libutils/isoc/sub.mk
+++ b/lib/libutils/isoc/sub.mk
@@ -38,3 +38,9 @@ endif
 
 subdirs-y += newlib
 subdirs-y += arch/$(ARCH)
+
+cflags-y += -fno-sanitize=all
+cflags-remove-y += -fsanitize-coverage=trace-pc
+
+# cflags-remove-bget.c-y += -fno-sanitize=all
+# cflags-remove-bget_malloc.c-y += -fno-sanitize=all
-- 
2.25.1

